from collections import namedtuple
import numpy as np
from typing import Any


def simulate(
    n: np.array, n_vax: np.array, K: np.array, p_severe: np.array, ve: float
) -> dict[str, Any]:
    """
    Calculate Re and distribution of infections

    Args:
        n (np.array): Population sizes for each group
        n_vax (np.array): Number of people vaccinated in each group
        K (np.array): Square matrix with entries representing between and within group R_0
        p_severe (np.array): Group-specific probability of severe infection
        ve (float): Vaccine efficacy

    Returns:
        dict: Contains dominant eigenvalue, dominant eigenvector, and adjusted NGM accounting for vaccination
    """
    n_groups = len(n)
    assert len(n_vax) == n_groups
    assert len(p_severe) == n_groups
    assert K.shape[0] == n_groups
    assert K.shape[1] == n_groups
    assert all(n >= n_vax), "Vaccinated cannot exceed population size"

    # eigen analysis
    p_vax = n_vax / n
    reduced_K = vaccinated_K(K=K, p_vax=p_vax, ve=ve)
    eigen = dominant_eigen(reduced_K)

    return {
        "reduced_K": reduced_K,
        "Re": eigen.value,
        "infections": eigen.vector,
        "severe_infections": eigen.vector * p_severe,
    }


def vaccinated_K(K: np.array, p_vax: np.array, ve: float) -> np.array:
    """Adjust a next generation matrix with vaccination

    Matrix element K_ij is how many infections in group j will
    be generated by a single infection in group i. Assume that vaccination
    reduces K_ij by a factor of 1 - p_vax_j * ve.

    Args:
        K (np.array): Next generation matrix. Must be square.
        p_vax (np.array): Proportion vaccinated in each group. Should have
          length equal to either of K's dimensions.
        ve (float): Vaccine efficacy

    Returns:
        np.array: matrix of the same shape as K
    """
    assert len(K.shape) == 2 and K.shape[0] == K.shape[1], "K must be square"
    assert K.shape[0] == len(p_vax), "Input dimensions must match"
    assert 0 <= ve <= 1.0
    assert all(0 <= p_vax) and all(p_vax <= 1.0)

    # note that * here is column-wise multiplication
    return K * (1.0 - p_vax * ve)


def dominant_eigen(X: np.array, norm: str = "L1") -> namedtuple:
    """Dominant eigenvalue and eigenvector of a matrix

    Args:
        X (np.array): matrix
        norm (str, optional): Vector norm. `np.linalg.eig()` returns
          a result with `"L2"` norm. Defaults to "L1", in which case
          the sum of the vector values is 1.

    Returns:
        namedtuple: with entries `value` and `vector`
    """
    # do the eigenvalue analysis
    e = np.linalg.eig(X)
    # which eigenvalue is the dominant one?
    i = np.argmax(np.abs(e.eigenvalues))

    value = e.eigenvalues[i]
    vector = _ensure_positive_array(e.eigenvectors[:, i])

    if not value > 0:
        raise RuntimeError(f"Negative dominant eigenvalue: {value}")
    if not all(vector >= 0):
        raise RuntimeError(f"Negative dominant eigenvector values: {vector}")

    if norm == "L2":
        pass
    elif norm == "L1":
        vector /= sum(vector)
    else:
        raise RuntimeError(f"Unknown norm '{norm}'")

    return namedtuple("DominantEigen", ["value", "vector"])(value=value, vector=vector)


def _ensure_positive_array(x: np.array) -> np.array:
    """Ensure all entries of an array are positive"""
    if all(x >= 0):
        return x
    elif all(x < 0):
        return -x
    else:
        raise RuntimeError(f"Cannot make vector all positive: {x}")
